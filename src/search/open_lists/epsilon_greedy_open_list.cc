#include "epsilon_greedy_open_list.h"
#include "tiebreaking_open_list.h"

#include "open_list.h"

#include "../globals.h"
#include "../option_parser.h"
#include "../plugin.h"

#include "../utils/collections.h"
#include "../utils/memory.h"
#include "../utils/rng.h"

#include <functional>
#include <memory>
#include <deque>

using namespace std;


template<class Entry>
class EpsilonGreedyOpenList : public TieBreakingOpenList<Entry> {
    double epsilon;
    bool h_bias;

public:
    explicit EpsilonGreedyOpenList(const Options &opts);
    virtual ~EpsilonGreedyOpenList() override = default;

    virtual typename Buckets<Entry>::iterator get_bucket(std::vector<int> *key) override;
};

template<class Entry>
EpsilonGreedyOpenList<Entry>::EpsilonGreedyOpenList(const Options &opts)
    : TieBreakingOpenList<Entry>(opts),
      epsilon(opts.get<double>("epsilon")),
      h_bias(opts.get<bool>("h_bias")) {
}

template<class Entry>
typename Buckets<Entry>::iterator EpsilonGreedyOpenList<Entry>::get_bucket(vector<int> *key) {
    auto &buckets = this->buckets;
    auto &size = this->size;
    auto it = buckets.begin();
    assert(it != buckets.end());
    if (g_rng() < epsilon) {
        if (h_bias){
            int pos = g_rng(buckets.size());
            for (int i = 0; i < pos; i++){
                it++;
            }
        } else {
            int pos = g_rng(size);
            int tmp_size = 0;
            while (tmp_size < pos){
                it++;
                tmp_size += it->second.size();
            }
        }
    }
    assert(!it->second.empty());
    if (key) {
        assert(key->empty());
        *key = it->first;
    }
    return it;
}

EpsilonGreedyOpenListFactory::EpsilonGreedyOpenListFactory(
    const Options &options)
    : options(options) {
}

unique_ptr<StateOpenList>
EpsilonGreedyOpenListFactory::create_state_open_list() {
    return Utils::make_unique_ptr<EpsilonGreedyOpenList<StateOpenListEntry>>(options);
}

unique_ptr<EdgeOpenList>
EpsilonGreedyOpenListFactory::create_edge_open_list() {
    return Utils::make_unique_ptr<EpsilonGreedyOpenList<EdgeOpenListEntry>>(options);
}

static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {
    parser.document_synopsis(
        "Epsilon-greedy open list",
        "Chooses an entry uniformly randomly with probability "
        "'epsilon', otherwise it returns the minimum entry. "
        "The algorithm is based on\n\n"
        " * Richard Valenzano, Nathan R. Sturtevant, "
        "Jonathan Schaeffer, and Fan Xie.<<BR>>\n"
        " [A Comparison of Knowledge-Based GBFS Enhancements and "
        "Knowledge-Free Exploration "
        "http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7943/8066]."
        "<<BR>>\n "
        "In //Proceedings of the Twenty-Fourth International "
        "Conference on Automated Planning and Scheduling (ICAPS "
        "2014)//, pp. 375-379. AAAI Press 2014.\n\n\n");
    parser.add_list_option<ScalarEvaluator *>("evals", "scalar evaluators");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<double>(
        "epsilon",
        "probability for choosing the next entry randomly",
        "0.2",
        Bounds("0.0", "1.0"));
    parser.add_option<bool>(
        "h_bias",
        "Randomize over buckets, rather than over all OPEN", "true");
    parser.add_option<bool>(
        "unsafe_pruning",
        "allow unsafe pruning when the main evaluator regards a state a dead end",
        "true");

    add_queue_type_option_to_parser(parser);

    Options opts = parser.parse();
    if (parser.dry_run()) {
        return nullptr;
    } else {
        return make_shared<EpsilonGreedyOpenListFactory>(opts);
    }
}

static PluginShared<OpenListFactory> _plugin("epsilon_greedy", _parse);
